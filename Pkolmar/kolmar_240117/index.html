<!DOCTYPE html>
<!-- _layouts/distill.html -->
<html>
  <head>    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Bumjini | [연구 14] 원료와 물성에 대한 모든 모델링</title>
    <meta name="author" content="Bumjini  " />
    <meta name="description" content="정보처리 관점에서 가능한 모델링 방식들에 대한 나열 및 실험 결과" />
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website" />


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light" />

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🪴</text></svg>">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://fxnnxc.github.io/Pkolmar/kolmar_240117/">
    
    <!-- Dark Mode -->
    


    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams',
        inlineMath: [['$','$'], ['\\(','\\)']]
      },
      chtml: {
          scale: 1.0,
          minScale: .6,  
          mtextFontInherit: true,
          mtextInheritFont: true,
          merrorInheritFont: true,
        },
        svg: {
          scale: 1.2
        }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    
  </head>

  <d-front-matter>
    <script async type="text/json">{
      "title": "[연구 14] 원료와 물성에 대한 모든 모델링",
      "description": "정보처리 관점에서 가능한 모델링 방식들에 대한 나열 및 실험 결과",
      "published": "January 16, 2024",
      "authors": [
        {
          "author": "Bumjin Park",
          "authorURL": "",
          "affiliations": [
            {
              "name": "KAIST",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  <body class="sticky-bottom-footer">

    <!-- Header -->    
    <center>
      <img src="/assets/common/KAIST-hi.gif" width="40px" style="margin-right:0px; padding-bottom: 3px;">
    </center>
    <hr> 

    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1 style="font-size: 32px;">[연구 14] 원료와 물성에 대한 모든 모델링</h1>
        <p>정보처리 관점에서 가능한 모델링 방식들에 대한 나열 및 실험 결과</p>
      </d-title>

      <d-byline></d-byline>

      <d-article>
        

        <h2 id="1-처방-물성-예측-문제">1. 처방 물성 예측 문제</h2>

<p>처방의 물성을 예측하는 문제는 신경망에 처방의 정보와 예측 물성의 정보를 넣어 기대값을 예측하는 문재이다.</p>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21833&amp;authkey=%21AA9mhP3YbvPbpfI&amp;width=2798&amp;height=1488" style="width:70%"> 
</center>

<p>입력으로 들어가는 정보는 원료의 정보와 함량, 그리고 물성에 대한 정보이다. 
가장 기본적인 방식은 각 물성마다 신경망을 구성하는 것인데, 이는 확장성이 제한적이다. 
새로운 물성을 예측할 때 새로운 신경망이 학습되어야 한다.</p>

<p>물성 예측 문제에서 원료의 정보가 충분하여 이를 바탕으로 함량과 섞어서 푸는 방식은 원료의 정보가 충분히 잘 구성되어야 가능하다 (그러나 현재 데이터는 그렇지 못하다). 
이에 현재 학습 알고리즘은 물성 예측을 위해 원료에 대한 적절한 표현을 찾으며 이를 입력으로 예측까지 진행한다.</p>

<h2 id="11-학습의-의미">1.1 학습의 의미</h2>

<p>대표적으로 2개의 처방 예시를 보자. 파란색 원료가 들어가고 나머지 두 개 원료는 다른 종류로 바꿨다. 첫 번째 처방을 학습할 때 원료 표현들은 물성예측에 대한 에러를 최소화 한다. 
그 과정에서 원료 표현들도 바뀌며 파란색 원료는 노란색 원료와 처방으로 구성되었을 때 예측값을 최소화하도록 학습된다. 
두 번째 처방을 학습하게 되면, 파란색 원료와 초록색 원료가 업데이트 된다. 따라서 파란색은 두 번 업데이트가 되며, 노란색 및 초록색과 처방을 구성했을 때 에러를 최소한으로 가지도록 학습된다. 
원료의 조합으로 구성된 처방은 여러 원료들의 조합이며, 학습데이터로 주어진 조합에 대해서 물성 예측 최소화를 진행하며 학습된다.</p>

<p>학습모델은 두 가지 학습 목표를 가진다.</p>
<ol>
  <li>원료 표현으로 물성 예측하기 (섞어서 물성 예측)</li>
  <li>원료 표현 형성</li>
</ol>

<p>따라서 모델을 학습하는 과정에서 두 가지 업데이트가 모두 발생하며, 이후 사용할 때는 임의의 원료들을 섞었을 때, 물성을 예측하기를 기대한다.</p>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21856&amp;authkey=%21ANYltdw6q9LDhJs&amp;width=1116&amp;height=563" style="width:100%"> 
</center>

<h2 id="12-필요-학습-데이터">1.2 필요 학습 데이터</h2>

<p>학습데이터는 처방과 물성 레이블 (pH, 점도, 경도, 비중)로 구성된다. 
고정된 처방에 대해서 물성은 측정할 경우 값이 생기며, 일부 물성은 데이터 수가 적다. 
예를 들어서 아래 그림에서 점도가 측정된 처방은 2개만 존재하며 위 학습에 의하면, 점도를 위한 표현과 점도를 섞는 것을 학습해야 한다. 
그러나 학습데이터 수가 적기에 이는 제대로 학습되지 않는다.</p>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21857&amp;authkey=%21APAaubv88FA_exU&amp;width=901&amp;height=580" style="width:100%"> 
</center>

<h2 id="13-실제-데이터-분포">1.3 실제 데이터 분포</h2>

<p>pH를 포함한 물성이 점도보다 많은 데이터를 포함할지라도 원료 조합으로 만들 수 있는 처방은 그 수가 무수히 많다. 
아래 그림은 입력데이터 (원료)에 대한 복잡도를 나타내며, 원료 개수 및 처방 내 원료 개수가 늘어남에 따라서 만들어지는 조합의 개수를 표현한 그림이다. 
조합의 복잡도를 줄이기 위해서는 두 가지 인자: 전체 원료 수, 처방 내 원료 수를 줄여야 한다.</p>

<ul>
  <li>신경망: 신경망은 주어진 많은 원료 중에서 필요한 원료를 선별하도록 학습될 수 있다. (그러나 이 방식은 원료 표현이 고정적이여야 안정적이다).</li>
  <li>전문가: 도메인 전문가는 유사한 특징을 지니는 원료를 알 수 있으며, 이들을 묶는 (클러스터링)하는 방식은 원료 수를 줄일 수 있다.</li>
</ul>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21858&amp;authkey=%21AOij85ZaksMwZ0c&amp;width=1060&amp;height=443" style="width:100%"> 
</center>

<h2 id="2-모델-카테고리">2. 모델 카테고리</h2>

<p>2023년까지 연구된 신경망의 설계는 제한된 형태를 이루며, 이들 중 다중 원료를 처리하는 구조적 해결책이 존재한다. 
이 장에서는 가장 단순한 모델부터 복잡한 모델까지 구조를 설명하며 처방을 처리하고 물성을 예측하는데 적합한 모델을 논의한다. 
모델 카테고리는 크게 세 종류가 있다.</p>
<ol>
  <li>
<strong>MLP</strong> : Multi-layer perceptron은 연속적인 N개의 레이어에 벡터를 처리해서 값을 얻는 방식이다.</li>
  <li>
<strong>RNN</strong> : Recurrent neural network는 원료 벡터를 순차적으로 넣어서 처리하고 물성 예측값을 얻는 방식이다.</li>
  <li>
<strong>Attention</strong> : 어텐션 방식은 원료 간/ 원료 및 물성 간의 가중치를 바탕으로 물성 예측값을 얻는 방식이다.</li>
</ol>

<center>
MLP 
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21854&amp;authkey=%21AK7on2sAMWgC3iI&amp;width=1336&amp;height=580" style="width:100%"> 
</center>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21849&amp;authkey=%21ABGGVIo0TkCmcwU&amp;width=1332&amp;height=588" style="width:100%"> 
</center>

<center>
RNN
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21853&amp;authkey=%21AAjK5FHaxHhLYXs&amp;width=1337&amp;height=584" style="width:100%"> 
</center>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21852&amp;authkey=%21AIJ0p4V-2yHZXqs&amp;width=1337&amp;height=589" style="width:100%"> 
</center>

<center>
ATTENTION
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21850&amp;authkey=%21AHwP0VV_ZDjnLBQ&amp;width=1338&amp;height=591" style="width:100%"> 
</center>
<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21851&amp;authkey=%21ALvS1_Ie4fBlbm8&amp;width=1338&amp;height=591" style="width:100%"> 
</center>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21855&amp;authkey=%21AG6Ql0TfGYR0fnc&amp;width=1326&amp;height=588" style="width:100%"> 
</center>

<h2 id="3-실험">3. 실험</h2>

<p>학습데이터는 다음 6개 물성이다. 점도의 경우 측정 방식에 따라서 다른 물성으로 고려하였다. 
위 모델 중 일부는 물성표현을 사용하여 모든 묾성을 동시에 학습할 수 있다. 
그러나 여러 물성을 동시에 학습할 경우, 예측을 잘하는 물성과 못하는 물성에 대한 가중치를 구분하기 어렵기 때문에 
개별적인 모델로 각 물성을 학습한다.</p>

<div>
  <table style="width:50%">
  <tr>
<th>  data  </th> <th>  size  </th>
</tr>
  <tr>
<td> density </td>  <td> 7836 </td>
</tr>
  <tr>
<td> hardness </td>  <td> 2441 </td>
</tr>
  <tr>
<td> pH </td>  <td> 7441 </td>
</tr>
  <tr>
<td> viscosity_3_12 </td>  <td> 499 </td>
</tr>
  <tr>
<td> viscosity_4_12 </td>  <td> 276 </td>
</tr>
  <tr>
<td> viscosity_4_6 </td>  <td> 1731 </td>
</tr>
  </table>
</div>

<h2 id="4-결과">4. 결과</h2>

<p>각 물성에 대한 학습 결과는 얼마나 잘 암기하는지 보여준다. 
각 물성에 대한 테스트 결과는 얼마나 새로운 (처방, 원료)에 대해서 잘 적응하는지 보여준다.<br>
각 점수는 에러율로 낮을수록 좋다. L1 loss 값은 정규화된 Y에 대한 값으로 에러가 클수록 예측 성능이 낮음을 나타낸다.</p>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21863&amp;authkey=%21AEE05h3Ao8NHpM8&amp;width=1263&amp;height=813" style="width:100%"> 
</center>

<p>아래 그림은 위 그래프에 대한 Radar Plot을 나타낸다.</p>

<center>
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21862&amp;authkey=%21AJt5xto3eq7WWuY&amp;width=727&amp;height=557" style="width:49%"> 
<img src="https://onedrive.live.com/embed?resid=AE042A624064F8CA%21864&amp;authkey=%21AErPCfJmmOzja-Y&amp;width=660" style="width:49%"> 
</center>


      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>


      <hr>
<!--<div id="giscus_thread" style="max-width: 1000px; margin: 0 auto;">
    <script>
      let giscusTheme = localStorage.getItem("theme");
      let giscusAttributes = {
          "src": "https://giscus.app/client.js",
          "data-repo": "fxnnxc/fxnnxc",
          "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjQ2NjUxMTU=",
          "data-category": "Q&A",
          "data-category-id": "DIC_kwDOE1n_G84CYOk_",
          "data-mapping": "title",
          "data-strict": "0",
          "data-reactions-enabled": "1",
          "data-emit-metadata": "0",
          "data-input-position": "top",
          "data-theme": giscusTheme,
          "data-lang": "en",
          "crossorigin": "anonymous",
          "async": "",
      };
  
  
      let giscusScript = document.createElement("script");
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById("giscus_thread").appendChild(giscusScript);
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript">comments powered by giscus.</a></noscript>
  </div>--><div id="giscus_thread" style="max-width: 1000px; margin: 0 auto;">
    <script>
      let giscusTheme = localStorage.getItem("theme");
      let giscusAttributes = {
          "src": "https://giscus.app/client.js",
          "data-repo": "fxnnxc/fxnnxc",
          "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjQ2NjUxMTU=",
          "data-category": "Q&A",
          "data-category-id": "DIC_kwDOE1n_G84CYOk_",
          "data-mapping": "title",
          "data-strict": "0",
          "data-reactions-enabled": "1",
          "data-emit-metadata": "0",
          "data-input-position": "top",
          "data-theme": giscusTheme,
          "data-lang": "en",
          "crossorigin": "anonymous",
          "async": "",
      };
  
  
      let giscusScript = document.createElement("script");
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById("giscus_thread").appendChild(giscusScript);
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" target="_blank" rel="noopener noreferrer">comments powered by giscus.</a>
</noscript>
  </div>
</div>

    <!-- Footer -->    <footer class="sticky-bottom mt-5" style="border: none;border-top:0px">
      <div class="container" style="text-align: center; ">
        © Copyright 2024 Bumjini  . Powered by Jekyll with al-folio theme. Hosted by GitHub Pages.

      </div>
    </footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": 0 });
    $("progress-container").css({ "padding-top": 0 });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>

  <d-bibliography src="/assets/bibliography/">
  </d-bibliography>

  <!-- jQuery -->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="/assets/js/distillpub/overrides.js"></script>

    <center>
        <img src="/assets/common/KAIST-hi.gif" width="40px" style="margin-right:0px; padding-bottom: 3px;">
    </center>
    <hr> 

</html>
